<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Squashfs Format (WIP)</title>

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="icon" href="images/favicon.png">

    <style type="text/css">
        .field-name {
            color: #e39619;
            display: inline-block;
        }

        .flag-name {
            color: #ff00ce;
        }

        pre {
            background-color: #f8f9fa;
        }

        .avoid-split {
            display: inline-block;
        }

        BODY {
            margin-top: 75px;
        }

        *[id]:before {
            display: block;
            content: " ";
            margin-top: -75px;
            height: 75px;
            visibility: hidden;
        }

    </style>
</head>

<body>
    <nav class="navbar fixed-top navbar-expand-md navbar-light bg-light">
        <a class="navbar-brand" href="#">Squashfs Format</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">

                <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Sections</a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="#superblock">Superblock</a>
                        <a class="dropdown-item" href="#compression-options">Compression Options</a>
                        <a class="dropdown-item" href="#datablocks-and-fragments">Datablocks &amp; Fragments</a>
                        <a class="dropdown-item" href="#inode-table">Inode Table</a>
                        <a class="dropdown-item" href="#directory-table">Directory Table</a>
                        <a class="dropdown-item" href="#fragment-table">Fragment Table</a>
                        <a class="dropdown-item" href="#export-table">Export Table</a>
                        <a class="dropdown-item" href="#id-table">UID/GID Table</a>
                        <a class="dropdown-item" href="#xattr-table">Xattr Table</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="https://github.com/plougher/squashfs-tools">Repo</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="https://www.kernel.org/doc/Documentation/filesystems/squashfs.txt">Kernel Docs</a>
                </li>
            </ul>
        </div>

        <a href="https://github.com/Dr-Emann/Dr-Emann.github.io/tree/master/squashfs" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    </nav>

    <div id="main-container" class="container">
        <div class="row">
            <div class="col">
                <h1 class="display-3">Squashfs Binary Format (WIP)</h1>
            </div>
        </div>
        <div class="row">
            <div class="col-12">
                <p>
                    A squashfs filesystem consists of a maximum of nine parts, packed together on a byte alignment:
                </p>
                <table class="table table-bordered">
                    <tr>
                        <td><a href="#superblock"><span class="float-lg-left">Superblock</span>
                            <div class="text-muted d-block d-lg-inline-block float-none float-lg-right">Important information about the archive, including locations of other sections</div></a>
                        </td>
                    </tr>
                    <tr>
                        <td><a href="#compression-options"><span class="float-lg-left">Compression Options</span>
                            <div class="text-muted d-block d-lg-inline-block float-none float-lg-right">If non-default compression options have been used, then these are stored here.</div></a>
                        </td>
                    </tr>
                    <tr>
                        <td><a href="#datablocks-and-fragments"><span class="float-lg-left">Datablocks &amp; Fragments</span></a>
                            <div class="text-muted d-block d-lg-inline-block float-none float-lg-right">The contents of the files in the archive, split into blocks</div>
                        </td>
                    </tr>
                    <tr>
                        <td><a href="#inode-table"><span class="float-lg-left">Inode Table</span>
                            <div class="text-muted d-block d-lg-inline-block float-none float-lg-right">Metadata (ownership, permissions, etc) for items in the archive</div>
                            </a>
                        </td>
                    </tr>
                    <tr>
                        <td><a href="#directory-table"><span class="float-lg-left">Directory Table</span>
                            <div class="text-muted d-block d-lg-inline-block float-none float-lg-right">Directory listings, including file names, and references to inodes</div>
                            </a>
                        </td>
                    </tr>
                    <tr>
                        <td><a href="#fragment-table"><span class="float-lg-left">Fragment Table</span>
                            <div class="text-muted d-block d-lg-inline-block float-none float-lg-right">Description of fragment locations within the Datablocks &amp; Fragments section</div>
                            </a>
                        </td>
                    </tr>
                    <tr>
                        <td><a href="#export-table"><span class="float-lg-left">Export Table</span>
                            <div class="text-muted d-block d-lg-inline-block float-none float-lg-right">A mapping from inode numbers to disk locations, required for NFS export</div>
                        </td>
                    </tr>
                    <tr>
                        <td><a href="#id-table"><span class="float-lg-left">UID/GID Lookup Table</span>
                            <div class="text-muted d-block d-lg-inline-block float-none float-lg-right">A list of UID/GIDs. IDs are referenced as an index into this table</div></a>
                        </td>
                    </tr>
                    <tr>
                        <td><a href="#xattr-table"><span class="float-lg-left">Xattr Table</span>
                            <div class="text-muted d-block d-lg-inline-block float-none float-lg-right">Xattrs for items in the archive</div></a>
                        </td>
                    </tr>
                </table>
            </div>
            <div class="col">
                <section id="superblock">
                    <h1>The superblock</h1>
                    <p>
                        The superblock is the first section of a squashfs archive, and contains important information about the archive, including the locations of other sections of the archive.
                    </p>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code class="field-name">magic</code></td>
                                <td>u32</td>
                                <td>Must match the value of <code>0x73717368</code> to be considered a squashfs archive</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">inode_count</code></td>
                                <td>u32</td>
                                <td>The number of inodes stored in the inode table</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">modification_time</code></td>
                                <td>u32</td>
                                <td>The number of seconds (not counting leap seconds) since 00:00, Jan&nbsp;1&nbsp;1970 UTC when the archive was created (or last appended to).
                                This is <b>unsigned</b>, so it expires in the year 2106 (as opposed to 2038).</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">block_size</code></td>
                                <td>u32</td>
                                <td>The size of a data block in bytes. Must be a power of two between 4096 and 1048576 (1 MiB)</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">fragment_entry_count</code></td>
                                <td>u32</td>
                                <td>The number of entries in the fragment table</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">compression_id</code></td>
                                <td>u16</td>
                                <td>
                                    <div class="row">
                                        <div class="col-12 col-sm-6 col-md-3">1&nbsp;-&nbsp;GZIP</div>
                                        <div class="col-12 col-sm-6 col-md-3">2&nbsp;-&nbsp;LZMA</div>
                                        <div class="col-12 col-sm-6 col-md-3">3&nbsp;-&nbsp;LZO</div>
                                        <div class="col-12 col-sm-6 col-md-3">4&nbsp;-&nbsp;XZ</div>
                                        <div class="col-12 col-sm-6 col-md-3">5&nbsp;-&nbsp;LZ4</div>
                                        <div class="col-12 col-sm-6 col-md-3">6&nbsp;-&nbsp;ZSTD</div>
                                    </div>
                                </td>
                            </tr>
                            <tr>
                                <td><code class="field-name">block_log</code></td>
                                <td>u16</td>
                                <td>The log<sub>2</sub> of <code class="field-name">block_size</code>. If <code class="field-name">block_size</code> and <code class="field-name">block_log</code> do not agree, the archive is considered corrupt</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">flags</code></td>
                                <td>u16<br/>(<a href="#superblock-flags">Flags</a>)</td>
                                <td><em>See <a href="#superblock-flags">Superblock Flags</a></em></td>
                            </tr>
                            <tr>
                                <td><code class="field-name">id_count</code></td>
                                <td>u16</td>
                                <td>The number of entries in the id lookup table</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">version_major</code></td>
                                <td>u16</td>
                                <td>The major version of the squashfs file format. Should always equal 4</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">version_minor</code></td>
                                <td>u16</td>
                                <td>The minor version of the squashfs file format. Should always equal 0</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">root_inode_ref</code></td>
                                <td>u64<br/>(<a href="#InodeRef">InodeRef</a>)</td>
                                <td>A reference to the inode of the root directory of the archive</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">bytes_used</code></td>
                                <td>u64</td>
                                <td>The number of bytes used by the archive. Because squashfs archives are often padded to 4KiB, this can often be less than the file size</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">id_table_start</code></td>
                                <td>u64</td>
                                <td>The byte offset at which the id table starts</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">xattr_id_table_start</code></td>
                                <td>u64</td>
                                <td>The byte offset at which the xattr id table starts</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">inode_table_start</code></td>
                                <td>u64</td>
                                <td>The byte offset at which the inode table starts</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">directory_table_start</code></td>
                                <td>u64</td>
                                <td>The byte offset at which the directory table starts</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">fragment_table_start</code></td>
                                <td>u64</td>
                                <td>The byte offset at which the fragment table starts</td>
                            </tr>
                            <tr>
                                <td><code class="field-name">export_table_start</code></td>
                                <td>u64</td>
                                <td>The byte offset at which the export table starts</td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <section id="superblock-flags">
                    <h1>Superblock Flags</h1>

                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Value</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code class="flag-name">UNCOMPRESSED_INODES</code></td>
                                <td>0x0001</td>
                                <td>Inodes are stored uncompressed. For backward compatibility reasons, UID/GIDs are also stored uncompressed.</td>
                            </tr>
                            <tr>
                                <td><code class="flag-name">UNCOMPRESSED_DATA</code></td>
                                <td>0x0002</td>
                                <td>Data are stored uncompressed</td>
                            </tr>
                            <tr>
                                <td><code class="flag-name">CHECK</code></td>
                                <td>0x0004</td>
                                <td>Unused in squashfs 4+. Should always be unset</td>
                            </tr>
                            <tr>
                                <td><code class="flag-name">UNCOMPRESSED_FRAGMENTS</code></td>
                                <td>0x0008</td>
                                <td>Fragments are stored uncompressed</td>
                            </tr>
                            <tr>
                                <td><code class="flag-name">NO_FRAGMENTS</code></td>
                                <td>0x0010</td>
                                <td>Fragments are not used. Files smaller than the block size are stored in a full block.</td>
                            </tr>
                            <tr>
                                <td><code class="flag-name">ALWAYS_FRAGMENTS</code></td>
                                <td>0x0020</td>
                                <td>If the last block of a file is smaller than the block size, it will be instead stored as a fragment</td>
                            </tr>
                            <tr>
                                <td><code class="flag-name">DUPLICATES</code></td>
                                <td>0x0040</td>
                                <td>Identical files are recognized, and stored only once</td>
                            </tr>
                            <tr>
                                <td><code class="flag-name">EXPORTABLE</code></td>
                                <td>0x0080</td>
                                <td>Filesystem has support for export via NFS (The export table is populated)</td>
                            </tr>
                            <tr>
                                <td><code class="flag-name">UNCOMPRESSED_XATTRS</code></td>
                                <td>0x0100</td>
                                <td>Xattrs are stored uncompressed</td>
                            </tr>
                            <tr>
                                <td><code class="flag-name">NO_XATTRS</code></td>
                                <td>0x0200</td>
                                <td>Xattrs are not stored</td>
                            </tr>
                            <tr>
                                <td><code class="flag-name">COMPRESSOR_OPTIONS</code></td>
                                <td>0x0400</td>
                                <td>The compression options section is present</td>
                            </tr>
                            <tr>
                                <td><code class="flag-name">UNCOMPRESSED_IDS</code></td>
                                <td>0x0800</td>
                                <td>UID/GIDs are stored uncompressed. Note that the <code class="flag-name">UNCOMPRESSED_INODES</code> flag also has this effect. If that flag is set, this flag has no effect. This flag is currently only available on master in git, no released version of squashfs yet supports it.</td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <section id="metadata-blocks">
                    <h1>Metadata Blocks</h1>
                    <p>
                        Metadata blocks are compressed in 8KiB blocks. A metadata block is prefixed by a u16 header. The highest bit of the header is set if the block is stored uncompressed (this will happen if the block grew when compressed, or e.g. the <code class="flag-name">UNCOMPRESSED_INODES</code> superblock flag is set). The lower 15 bits specifies the size of the metadata block (not including the header) on disk.
                    </p>
                    <p>
                        To read a metadata block, read a u16. If the highest bit is set (<code>size &amp; 0x8000 == 0x8000</code>) the following data is uncompressed. Mask out the highest bit to get the size of the block data on disk (this should always be &lt;= 8KiB). Read that many bytes. If the data is compressed, uncompress the data. In pseudocode:
                    </p>
                    <pre class="pre-scrollable pseudocode example"><code>header = read_u16(offset=offset)
data_size = header &amp; 0x7FFF
compressed = header &amp; 0x8000
data = read(offset=offset+2, len=data_size)
if(compressed) {
    data = uncompress(data)
}
return data</code></pre>
                    <p>
                        Neither the size on disk, nor the compressed size should exceed 8KiB. The uncompressed size should always be equal to 8KiB, with the exception of the last metadata block of a section, which may have an uncompressed size less than 8KiB.
                    </p>
                </section>

                <section id="compression-options">
                    <h1>Compression Options</h1>
                    <p>
                        If the <code class="flag-name">COMPRESSOR_OPTIONS</code> flag is set, this section will be present immidately after the superblock, otherwise this section will not be present. If this section is present, it consists of a single <a href="#metadata-blocks">metadata block</a>, which is always uncompressed. The data is interpreted differently based on the compressor <span class="avoid-split">(<code class="field-name">compression_id</code>).</span>
		    </p>
		    <p>
                        For LZ4, the compressor options <i>always</i> have to be present.
		    </p>
                    <div class="row">
                        <div class="col-12">
                            <h4>LZMA</h4>
                            <p>LZMA does not support any compression options</p>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h4>GZIP</h4>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>compression_level</td>
                                        <td>i32</td>
                                        <td>Should be in range 1&hellip;9 (inclusive). Defaults to 9.</td>
                                    </tr>
                                    <tr>
                                        <td>window_size</td>
                                        <td>i16</td>
                                        <td>Should be in range 8&hellip;15 (inclusive) Defaults to 15.</td>
                                    </tr>
                                    <tr>
                                        <td>strategies</td>
                                        <td>i16</td>
                                        <td>A bitfield describing the enabled strategies. If no flags are set, the default strategy is implicitly used. Flags:
                                            <table class="table table-sm table-bordered font-weight-light">
                                                <tbody>
                                                    <tr>
                                                        <td>Default</td>
                                                        <td>0x01</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Filtered</td>
                                                        <td>0x02</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Huffman Only</td>
                                                        <td>0x04</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Run Length Encoded</td>
                                                        <td>0x08</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Fixed</td>
                                                        <td>0x10</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h4>XZ</h4>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>dictionary_size</td>
                                        <td>i32</td>
                                        <td>Should be > 8KiB, and must be either the sum of a power of two, or the sum of two sequential powers of two
                                            <span class="avoid-split">(2<sup>n</sup> or 2<sup>n</sup>&nbsp;+&nbsp;2<sup>n+1</sup>)</span></td>
                                    </tr>
                                    <tr>
                                        <td>executable_filters</td>
                                        <td>i32</td>
                                        <td>A bitfield describing the additional enabled filters attempted to better compress executable code. Flags:
                                            <table class="table table-sm table-bordered font-weight-light">
                                                <tbody>
                                                    <tr>
                                                        <td>x86</td>
                                                        <td>0x01</td>
                                                    </tr>
                                                    <tr>
                                                        <td>powerpc</td>
                                                        <td>0x02</td>
                                                    </tr>
                                                    <tr>
                                                        <td>ia64</td>
                                                        <td>0x04</td>
                                                    </tr>
                                                    <tr>
                                                        <td>arm</td>
                                                        <td>0x08</td>
                                                    </tr>
                                                    <tr>
                                                        <td>armthumb</td>
                                                        <td>0x10</td>
                                                    </tr>
                                                    <tr>
                                                        <td>sparc</td>
                                                        <td>0x20</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h4>LZ4</h4>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>version</td>
                                        <td>i32</td>
                                        <td>The only supported value is 1 (<code>LZ4_LEGACY</code>)</td>
                                    </tr>
                                    <tr>
                                        <td>flags</td>
                                        <td>i32</td>
                                        <td>A bitfield describing the enabled LZ4 flags. There is currently only one possible flag:
                                            <table class="table table-sm table-bordered font-weight-light">
                                                <tbody>
                                                    <tr>
                                                        <td>Use LZ4 High Compression(HC) mode</td>
                                                        <td>0x01</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h4>ZSTD</h4>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>compression_level</td>
                                        <td>i32</td>
                                        <td>Should be in range 1..22 (inclusive). The real maximum is the zstd defined <code>ZSTD_maxCLevel()</code></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h4>LZO</h4>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>algorithm</td>
                                        <td>i32</td>
                                        <td>Which variant of LZO to use (default is lzo1x_999):
                                            <table class="table table-sm table-bordered font-weight-light">
                                                <tbody>
                                                    <tr>
                                                        <td>lzo1x_1</td>
                                                        <td>0</td>
                                                    </tr>
                                                    <tr>
                                                        <td>lzo1x_1_11</td>
                                                        <td>1</td>
                                                    </tr>
                                                    <tr>
                                                        <td>lzo1x_1_12</td>
                                                        <td>2</td>
                                                    </tr>
                                                    <tr>
                                                        <td>lzo1x_1_15</td>
                                                        <td>3</td>
                                                    </tr>
                                                    <tr>
                                                        <td>lzo1x_999</td>
                                                        <td>4</td>
                                                    </tr>
                                                </tbody>
                                            </table>
					</td>
                                    </tr>
                                    <tr>
                                        <td>level</td>
                                        <td>i32</td>
                                        <td>Compression level. For lzo1x_999,
                                        this can be a value between 0 and 9
                                        (defaults to 8). Has to be 0 for all
                                        other algorithms.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section id="datablocks-and-fragments">
                    <h1>Datablocks and Fragments</h1>
                    <p>
                        Datablocks and fragments contain the data which is contained by the files in this archive. A single file's data is stored in a number of data blocks, which are stored sequentially in this section. Because blocks are stored sequentially, the inode for a file only needs to store the position of the first block, and the compressed sizes of each block. All data blocks must be of size <code class="field-name">block_size</code>.
                    </p>
                    <p>
                        If the size of a file is not equally divisible by <code class="field-name">block_size</code>, the final chunk can either be stored in a short block that does not uncompress to full size, or it can be stored in a fragment, if fragments are enabled (<a href="#superblock-flags"><code class="flag-name">NO_FRAGMENTS</code></a> is not set).
                    </p>
                    <p>
                        Fragments of multiple files are combined into data blocks of at most size <code class="field-name">block_size</code>, and compressed as a single block (unless compression fails to shrink the fragment block).
                    </p>
                    <p>
                        Datablocks do not have headers. Information about the size and position of datablocks is stored in the inode of the file to which the datablocks belong. Information about the size and position of fragment blocks are stored in the <a href="#fragment-table">Fragment Table</a>, and the size and offset of fragments within the blocks are stored in the inode of the file to which the fragment belongs.
                    </p>
                    <p>
                        In both the fragment table, and file inodes, the size of a data block is represented by a u32. If the <code>1 &lt;&lt; 24</code> bit is set, the data block is stored uncompressed. The size of the block on disk is described by this u32 when this bit is masked out, though the value should always be less than the max block size (1MiB).
                    </p>
                    <p>
                        Sparse files are handled at <code class="field-name">block_size</code> granularty. If an entire block is found to be full of zero bytes, the block isn't written to disk. Instead a size of zero is stored in the inode.
                    </p>
                </section>
                <section id="inode-table">
                    <h1>Inode Table</h1>
                    <p>
                        The inode table starts at <code class="field-name">inode_table_start</code> and ends at <code class="field-name">directory_table_start</code>. In this range are stored enough <a href="#metadata-blocks">metadata blocks</a> to contain all inodes. All metablocks in the table (except for the last block) should have an uncompressed size of 8KiB.
                    </p>
                    <p>
                        Inodes are packed into metadata blocks. Inodes are not aligned to block boundaries, and can therefore span the boundary between metadata blocks. To maximise compression there are different inodes for each item type (regular file, directory, device, etc.), the inode contents and length varying with the type.
                    </p>
                    <p>
                        To further maximise compression, inodes come in two flavors: simple inode types optimised for frequently occurring items, and extended inode types where extra information has to be stored.
                    </p>
                    <p>
                        If the <code class="flag-name">UNCOMPRESSED_INODES</code> flag is set, all metadata blocks should stored uncompressed. If the flag is not set, metadata blocks will be stored compressed if compression decreases the size of the block as described in the <a href="#metadata-blocks">metadata block section</a>.
                    </p>

                    <h3 id="inode-references">Inode References</h3>
                    <p>
                        Entries in the Inode table are referenced (for example, in directory entries) with u64 values. The upper 16 bits are unused. The next 32 bits describe the index of the metadata block. The lower 16 bits describe the (uncompressed) offset within the metadata block where the inode <strong>begins</strong> (remember that an inode may straddle the border between two metadata blocks). For example, an inode reference with the value <code class="avoid-split">0x0000_000001FF_01A0</code> will be located in the metadata block at index <code>0x000001FF</code> (the 512th block), starting at the byte at index <code>0x01A0</code> (the 417th byte) when the block is uncompressed.
                    </p>

                    <h3 id="inode-header">Inode Header</h3>
                    <p>
                        All Inodes share a common header, which contains some common information, as well as describing the type of Inode which follows. This header has the following structure:
                    </p>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>inode_type</td>
                                <td>u16<br/>(<a href="#inode-types">InodeType</a>)</td>
                                <td>The type of item described by the inode which follows this header.</td>
                            </tr>
                            <tr>
                                <td>permissions</td>
                                <td>u16<br/>(<a href="#TODO-permissions-type">Permissions</a>)</td>
                                <td>A bitmask representing the permissions for the item described by the inode. The values match with the permission values of <a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/sysstat.h.html">mode_t</a> (the mode bits, not the file type)</td>
                            </tr>
                            <tr>
                                <td>uid_idx</td>
                                <td>u16</td>
                                <td>The index of the user id in the <a href="#id-table">UID/GID Table</a></td>
                            </tr>
                            <tr>
                                <td>gid_idx</td>
                                <td>u16</td>
                                <td>The index of the group id in the <a href="#id-table">UID/GID Table</a></td>
                            </tr>
                            <tr>
                                <td>modified_time</td>
                                <td>u32</td>
                                <td>The <i>unsigned</i> number of seconds (not counting leap seconds) since 00:00, Jan&nbsp;1&nbsp;1970 UTC when the item described by the inode was last modified</td>
                            </tr>
                            <tr>
                                <td>inode_number</td>
                                <td>u32</td>
                                <td>The position of this inode in the full list of inodes. Value should be in the range <span class="avoid-split"><code>[1, <span class="field-name">inode_count</span>]</code>
                                    </span>(from the <a href="#superblock">superblock</a>) This can be treated as a unique identifier for this inode, and can be used as a key to recreate hard links: when processing the archive, remember the visited values of <code>inode_number</code>. If an inode number has already been visited, this inode is hardlinked</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3 id="inode-types">Inode Types</h3>
                    <p>
                        There are seven types of inodes, and each type comes in two variants, a basic variant which is smaller and contains only the most-used properties, and an extended variant which has more properties, and will be used when those less used properties are required (e.g. xattrs). Note that some inodes types are variable sized (symlinks targets, sizes of file data blocks, etc).
                    </p>
                    <p>
                        The value of <code class="field-name">inode_type</code> (in the <a href="#inode-header">inode header</a>) can have any of the following values:
                    </p>
                    <div class="row">
                        <div class="col-12 col-sm-6 col-lg-3">1&nbsp;-&nbsp;<a href="#inode-directory-basic">Basic Directory</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">2&nbsp;-&nbsp;<a href="#inode-file-basic">Basic File</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">3&nbsp;-&nbsp;<a href="#inode-symlink-basic">Basic Symlink</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">4&nbsp;-&nbsp;<a href="#inode-device-basic">Basic Block Device</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">5&nbsp;-&nbsp;<a href="#inode-device-basic">Basic Char Device</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">6&nbsp;-&nbsp;<a href="#inode-ipc-basic">Basic Fifo</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">7&nbsp;-&nbsp;<a href="#inode-ipc-basic">Basic Socket</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">8&nbsp;-&nbsp;<a href="#inode-directory-extended">Extended Directory</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">9&nbsp;-&nbsp;<a href="#inode-file-extended">Extended File</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">10&nbsp;-&nbsp;<a href="#inode-symlink-extended">Extended Symlink</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">11&nbsp;-&nbsp;<a href="#inode-device-extended">Extended Block Device</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">12&nbsp;-&nbsp;<a href="#inode-device-extended">Extended Char Device</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">13&nbsp;-&nbsp;<a href="#inode-ipc-extended">Extended Fifo</a></div>
                        <div class="col-12 col-sm-6 col-lg-3">14&nbsp;-&nbsp;<a href="#inode-ipc-extended">Extended Socket</a></div>
                    </div>
                    <br/>
                    <div class="row">
                        <div class="col-12 col-lg-6">
                            <h5 id="inode-directory-basic">Basic Directory</h5>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>block_idx</td>
                                        <td>u32</td>
                                        <td>The index of the block in the <a href="#directory-table">Directory Table</a> where the directory entry information starts</td>
                                    </tr>
                                    <tr>
                                        <td>hard_link_count</td>
                                        <td>u32</td>
                                        <td>The number of hard links to this directory</td>
                                    </tr>
                                    <tr>
                                        <td>file_size</td>
                                        <td>u16</td>
                                        <td>Total (uncompressed) size in bytes of the entries in the <a href="#directory-table">Directory Table</a>, including headers</td>
                                    </tr>
                                    <tr>
                                        <td>block_offset</td>
                                        <td>u16</td>
                                        <td>The (uncompressed) offset within the block in the <a href="#directory-table">Directory Table</a> where the directory entry information starts</td>
                                    </tr>
                                    <tr>
                                        <td>parent_inode_number</td>
                                        <td>u32</td>
                                        <td>The <code class="field-name">inode_number</code> of the parent of this directory. If this is the root directory, this will be 1</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h5 id="inode-directory-extended">Extended Directory</h5>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>hard_link_count</td>
                                        <td>u32</td>
                                        <td>The number of hard links to this directory</td>
                                    </tr>
                                    <tr>
                                        <td>file_size</td>
                                        <td>u32</td>
                                        <td>Total (uncompressed) size in bytes of the entries in the <a href="#directory-table">Directory Table</a>, including headers</td>
                                    </tr>
                                    <tr>
                                        <td>block_idx</td>
                                        <td>u32</td>
                                        <td>The index of the block in the <a href="#directory-table">Directory Table</a> where the directory entry information starts</td>
                                    </tr>
                                    <tr>
                                        <td>parent_inode_number</td>
                                        <td>u32</td>
                                        <td>The <code class="field-name">inode_number</code> of the parent of this directory. If this is the root directory, this will be 1</td>
                                    </tr>
                                    <tr>
                                        <td>index_count</td>
                                        <td>u16</td>
                                        <td>One less than the number of directory index entries following the inode structure</td>
                                    </tr>
                                    <tr>
                                        <td>block_offset</td>
                                        <td>u16</td>
                                        <td>The (uncompressed) offset within the block in the <a href="#directory-table">Directory Table</a> where the directory entry information starts</td>
                                    </tr>
                                    <tr>
                                        <td>xattr_idx</td>
                                        <td>u32</td>
                                        <td>An index into the <a href="#xattr-table">xattr lookup table</a>. Set to 0xFFFFFFFF if the inode has no extended attributes</td>
                                    </tr>
                                    <tr>
                                        <td>index</td>
                                        <td>dir_index_t[index_count + 1]</td>
                                        <td>A list of <a href="#directory-index">directory index</a> entries for faster lookup in the directory table</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h5 id="inode-file-basic">Basic File</h5>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>blocks_start</td>
                                        <td>u32</td>
                                        <td>The offset from the start of the archive where the data blocks are stored</td>
                                    </tr>
                                    <tr>
                                        <td>fragment_block_index</td>
                                        <td>u32</td>
                                        <td>The index of a fragment entry in the <a href="fragment-table">fragment table</a> which describes the data block the fragment of this file is stored in. If this file does not end with a fragment, this should be 0xFFFFFFFF</td>
                                    </tr>
                                    <tr>
                                        <td>block_offset</td>
                                        <td>u32</td>
                                        <td>The (uncompressed) offset within the fragment data block where the fragment for this file. Information about the fragment can be found at <code class="field-name">fragment_block_index</code>. The size of the fragment can be found as <code><span class="field-name">file_size</span> % <span class="avoid-split">superblock.<span class="field-name">block_size</span></span></code> If this file does not end with a fragment, the value of this field is undefined (probably zero)</td>
                                    </tr>
                                    <tr>
                                        <td>file_size</td>
                                        <td>u32</td>
                                        <td>The (uncompressed) size of this file</td>
                                    </tr>
                                    <tr>
                                        <td>block_sizes</td>
                                        <td>u32[]</td>
                                        <td>A list of block sizes. If this file ends in a fragment, the size of this list is the number of <em>full</em> data blocks needed to store <code class="field-name">file_size</code> bytes. If this file does not have a fragment, the size of the list is the number of blocks needed to store <code class="field-name">file_size</code> bytes, rounded up. Each item in the list describes the (possibly compressed) size of a block. See <a href="#datablocks-and-fragments">datablocks &amp; fragments</a> for information about how to interpret this size.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h5 id="inode-file-extended">Extended File</h5>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>blocks_start</td>
                                        <td>u64</td>
                                        <td>The offset from the start of the archive where the data blocks are stored</td>
                                    </tr>
                                    <tr>
                                        <td>file_size</td>
                                        <td>u64</td>
                                        <td>The (uncompressed) size of this file</td>
                                    </tr>
                                    <tr>
                                        <td>sparse</td>
                                        <td>u64</td>
                                        <td>The number of bytes saved by omitting blocks of zero bytes. Used in the kernel for sparse file accounting</td>
                                    </tr>
                                    <tr>
                                        <td>hard_link_count</td>
                                        <td>u32</td>
                                        <td>The number of hard links to this node</td>
                                    </tr>
                                    <tr>
                                        <td>fragment_block_index</td>
                                        <td>u32</td>
                                        <td>The index of a fragment entry in the <a href="fragment-table">fragment table</a> which describes the data block the fragment of this file is stored in. If this file does not end with a fragment, this should be 0xFFFFFFFF</td>
                                    </tr>
                                    <tr>
                                        <td>block_offset</td>
                                        <td>u32</td>
                                        <td>The (uncompressed) offset within the fragment data block where the fragment for this file. Information about the fragment can be found at <code class="field-name">fragment_block_index</code>. If this file does not end with a fragment, the value of this field is undefined (probably zero)</td>
                                    </tr>
                                    <tr>
                                        <td>xattr_idx</td>
                                        <td>u32</td>
                                        <td>An index into the <a href="#xattr-table">xattr lookup table</a>. Set to 0xFFFFFFFF if the inode has no extended attributes</td>
                                    </tr>
                                    <tr>
                                        <td>block_sizes</td>
                                        <td>u32[]</td>
                                        <td>A list of block sizes. If this file ends in a fragment, the size of this list is the number of <em>full</em> data blocks needed to store <code class="field-name">file_size</code> bytes. If this file does not have a fragment, the size of the list is the number of blocks needed to store <code class="field-name">file_size</code> bytes, rounded up. Each item in the list describes the (possibly compressed) size of a block. See <a href="#datablocks-and-fragments">datablocks &amp; fragments</a> for information about how to interpret this size.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h5 id="inode-symlink-basic">Basic Symlink</h5>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>hard_link_count</td>
                                        <td>u32</td>
                                        <td>The number of hard links to this symlink</td>
                                    </tr>
                                    <tr>
                                        <td>target_size</td>
                                        <td>u32</td>
                                        <td>The size in bytes of the <code class="field-name">target_path</code> this symlink points to</td>
                                    </tr>
                                    <tr>
                                        <td>target_path</td>
                                        <td>u8[target_size]</td>
                                        <td>The target path this symlink points to. This path is <code class="field-name">target_size</code> bytes long. There is no trailing null byte</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h5 id="inode-symlink-extended">Extended Symlink</h5>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>hard_link_count</td>
                                        <td>u32</td>
                                        <td>The number of hard links to this symlink</td>
                                    </tr>
                                    <tr>
                                        <td>target_size</td>
                                        <td>u32</td>
                                        <td>The size in bytes of the <code class="field-name">target_path</code> this symlink points to</td>
                                    </tr>
                                    <tr>
                                        <td>target_path</td>
                                        <td>u8[target_size]</td>
                                        <td>The target path this symlink points to. This path is <code class="field-name">target_size</code> bytes long. There is no trailing null byte</td>
                                    </tr>
                                    <tr>
                                        <td>xattr_idx</td>
                                        <td>u32</td>
                                        <td>An index into the <a href="#xattr-table">xattr lookup table</a>. Set to 0xFFFFFFFF if the inode has no extended attributes</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h5 id="inode-device-basic">Basic Device (Block/Char)</h5>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>hard_link_count</td>
                                        <td>u32</td>
                                        <td>The number of hard links to this device</td>
                                    </tr>
                                    <tr>
                                        <td>device</td>
                                        <td>u32</td>
                                        <td>To extract the major device number, <code>(device &amp; 0xfff00) &gt;&gt; 8</code>. To extract the minor device number, use <code>(dev &amp; 0xff) | ((dev &gt;&gt; 12) &amp; 0xfff00)</code></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h5 id="inode-device-extended">Extended Device (Block/Char)</h5>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>hard_link_count</td>
                                        <td>u32</td>
                                        <td>The number of hard links to this device</td>
                                    </tr>
                                    <tr>
                                        <td>device</td>
                                        <td>u32</td>
                                        <td>To extract the major device number, <code>(device &amp; 0xfff00) &gt;&gt; 8</code>. To extract the minor device number, use <code>(dev &amp; 0xff) | ((dev &gt;&gt; 12) &amp; 0xfff00)</code></td>
                                    </tr>
                                    <tr>
                                        <td>xattr_idx</td>
                                        <td>u32</td>
                                        <td>An index into the <a href="#xattr-table">xattr lookup table</a>. Set to 0xFFFFFFFF if the inode has no extended attributes</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h5 id="inode-ipc-basic">Basic IPC (Fifo/Socket)</h5>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>hard_link_count</td>
                                        <td>u32</td>
                                        <td>The number of hard links to this ipc item</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="col-12 col-lg-6">
                            <h5 id="inode-ipc-extended">Extended IPC (Fifo/Socket)</h5>
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>hard_link_count</td>
                                        <td>u32</td>
                                        <td>The number of hard links to this ipc item</td>
                                    </tr>
                                    <tr>
                                        <td>xattr_idx</td>
                                        <td>u32</td>
                                        <td>An index into the <a href="#xattr-table">xattr lookup table</a>. Set to 0xFFFFFFFF if the inode has no extended attributes</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section id="directory-table">
                  <h1>Directory Table</h1>
                    <p>
                        For each directory inode, the directory table stores a list of all entries stored inside, with references back to the inodes that describe those entries.
                    </p>
                    <p>
                        The entry list is self is sorted ASCIIbetically by entry name. To save space, a delta encoding is used to store the inode number, i.e. the list is preceeded by a header with a reference inode number and all entries store the difference to that. Furthermore, the header also includes the location of a metadata block that the inodes of all of the following entries are in. The entries just store an offset into the uncompressed metadata block.
                    </p>
                    <h4 id="directory-header">Directory Header</h4>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>count</td>
                                <td>u32</td>
                                <td>Number of entries following the header</td>
                            </tr>
                            <tr>
                                <td>start</td>
                                <td>u32</td>
                                <td>The index of the block in the <a href="#inode-table">Inode Table</a> where the inodes is stored</td>
                            </tr>
                            <tr>
                                <td>inode number</td>
                                <td>u32</td>
                                <td>An arbitrary inode number. The entries that follow store their inode number as a difference to this. Typically the inode numbers are allocated in a continuous sequence for all children of a directory and the header simply stores the first one. Hard links of course break the sequence and require a new header if they are further away than +/- 32k of this number. Inode number allocation and picking of the reference could of course be optimized to prevent this</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>
                        Every time, the inode block changes or the difference of the inode number cannot be encoded in 16 bits anymore, a new header is emitted.
                    </p>
                    <p>
                        A header must not be followed by more than 256 entries. If there are more entries, a new header is emitted.
                    </p>
                    <p>
                        The file names are stored without trailing null bytes. Since a zero length name makes no sense, the name length is stored off-by-one, i.e. the value 0 cannot be encoded
                    </p>
                    <h4 id="directory-entry">Directory Entry</h4>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>offset</td>
                                <td>u16</td>
                                <td>An offset into the uncompressed inode metadata block</td>
                            </tr>
                            <tr>
                                <td>inode offset</td>
                                <td>i16</td>
                                <td>The difference of this inode's number to the reference stored in the header</td>
                            </tr>
                            <tr>
                                <td>type</td>
                                <td>u16</td>
                                <td>The <a href="#inode-types">inode type</a>. <b>For extended inodes, the corresponding basic type is stored here instead<b></td>
                            </tr>
                            <tr>
                                <td>name_size</td>
                                <td>u16</td>
                                <td>One less than the size of the entry name</td>
                            </tr>
                            <tr>
                                <td>name</td>
                                <td>u8[name_size + 1]</td>
                                <td>The file name of the entry without a trailing null byte</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>
                      The <a href="#inode-directory-basic">basic</a> and <a href="#inode-directory-extended">extended</a> inode types both have a size field that stores the uncompressed size of all the directory entries (including all headers) belonging to the inode. This field is used to deduce if more data is following while iterating over directory entries, even without knowing how many headers and partial lists there will be.
                    </p>
                    <h4 id="directory-index">Directory Index</h4>
                    <p>
                      To speed up lookups on directories with lots of entries, the <a href="#inode-directory-extended">extended directory inode</a> can store an index table, holding the locations of all <a href="#directory-header">directory headers</a> and the name of the first entry after the header.
                    </p>
                    <p>
                      To allow for fast lookups, a new <a href="#directory-header">directory header</a> should be emitted every time the entry list crosses a metadata block boundary.
                    </p>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>index</td>
                                <td>u32</td>
                                <td>This stores a byte offset from the first directory header to the current header, as if the uncompressed directory metadata blocks were laid out in memory consecutively.</td>
                            </tr>
                            <tr>
                                <td>start</td>
                                <td>u32</td>
                                <td>Start offset of a directory table metadata block</td>
                            </tr>
                            <tr>
                                <td>name_size</td>
                                <td>u32</td>
                                <td>One less than the size of the entry name</td>
                            </tr>
                            <tr>
                                <td>name</td>
                                <td>u8[name_size + 1]</td>
                                <td>The name of the first entry following the header without a trailing null byte</td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <section id="fragment-table">
                    <h1>Fragment Table</h1>
                    <p>
                        Fragments are combined into fragment blocks of at most <code class="field-name">block_size</code> bytes long. This table describes the location and size of these fragment blocks, not the fragments within them.
                    </p>
                    <p>
                        This table is stored in two levels: The fragment block entries are stored in <a href="#metadata-blocks">metadata blocks</a>, and the file offsets to these metadata blocks are stored at the offset specified by the <code class="field-name">fragment_table_start</code> field of the superblock.
                    </p>
                    <p>
                        Each metadata block can store 512 fragment block entries (16 bytes per fragment block entry), so there will be
                        <code>ceil(<span class="field-name">fragment_entry_count</span> / 512.0)</code> metadata blocks (and the same number of u64 offsets stored at
                        <code class="field-name">fragment_table_start</code>)
                    </p>
                    <p>
                        To read the list of fragment block entries, read <code>ceil(<span class="field-name">fragment_entry_count</span> / 512.0)</code> u64 offsets starting at
                        <code class="field-name">fragment_table_start</code>, then read the metadata blocks at the offsets read, interpreting the data of the metadata blocks as a packed array of fragment block entries.
                    </p>
                    <h4>Fragment Block Entry</h4>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>start</td>
                                <td>u64</td>
                                <td>The offset within the archive where the fragment block starts</td>
                            </tr>
                            <tr>
                                <td>size</td>
                                <td>u32</td>
                                <td>This stores two pieces of information. If the block is uncompressed, the 0x1000000 (1&lt;&lt;24) bit wil be set. The remaining bits describe the size of the fragment block on disk. Because the max value of <code class="field-name">block_size</code> is 1 MiB (1&lt;&lt;20), and the size of a fragment block should be less than <code class="field-name">block_size</code>, the uncompressed bit will never be set by the size.</td>
                            </tr>
                            <tr>
                                <td>_unused</td>
                                <td>u32</td>
                                <td>This field is unused</td>
                            </tr>
                        </tbody>
                    </table>
                </section>
                <section id="export-table">
                    <h1>Export Table</h1>
                    <p>
                        To support NFS exports, squashfs needs a fast way to resolve an inode number to an inode structure.
                    </p>
                    <p>
                        For this purpose, a squashfs archive can optionally contain an export table, which is basically a flat array of 64 bit <a href="#inode-references">inode references</a> with the inode number being used as an index into the array.
                    </p>
                    <p>
                        Because the inode number 0 is not used (as it is reserved as a sentinel value in Linux and other UNIX-like OS kernels), the array actually starts at inode number 1 and the index is thus <code><span class="field-name">inode_number</span> - 1</code>.
                    </p>
                    <p>
                        The array itself is stored in a series of <a href="#metadata-blocks">metadata blocks</a>. Since each block can store 1024 references (8 byte per reference), there will be <code>ceil(<span class="field-name">inode_count</span> / 1024.0)</code> metadata blocks for the entire array.
                    </p>
                    <p>
                        To locate the metadata blocks, a secondary list is used, containing the absolute, on-disk locations of the blocks. This list is stored uncompressed and starts at <code class="field-name">export_table_start</code>.
                    </p>
                </section>
                <section id="id-table">
                    <h1>UID/GID Table</h1>
                    <p>
                        UID/GIDs are both stored as u32s. Both UIDs and GIDs are treated as IDs, if a file is owned by user 1000, and group 1000, the ID 1000 will be stored only once. UID/GIDs in inodes are stored as u16 indexes into this table (and thus, a maximum of 65535 unique IDs may be stored).
                    </p>
                    <p>
                        This table is stored in two levels: The IDs are stored in <a href="#metadata-blocks">metadata blocks</a>, and the file offsets to these metadata blocks are stored at the offset specified by the <code class="field-name">id_table_start</code> field of the superblock.
                    </p>
                    <p>
                        Each metadata block can store 2048 UID/GIDs (4 bytes per ID), so there will be <code>ceil(<span class="field-name">id_count</span> / 2048.0)</code> metadata blocks used for IDs (and the same number of u64 offsets stored at <code class="field-name">id_table_start</code>).
                    </p>
                    <p>
                        To read the list of IDs, read <code>ceil(<span class="field-name">id_count</span> / 2048.0)</code> u64 offsets starting at
                        <code class="field-name">id_table_start</code>, then read the metadata blocks at the offsets read.
                    </p>
                </section>
                <section id="xattr-table">
                    <h1>Xattr Table</h1>
                    <p>
                        Extended attributes are arbitrary key value pairs attached to inodes. The key names use dots as separators to create a hierarchy of namespaces.
                    </p>
                    <p>
                        Squashfs uses multiple levels of indirection to store Xattr key value pairs associated with inodes. To saves space, the topmost namespace prefix is removed and encoded as an integer ID instead. This approach limits squashfs xattr support to the following, commonly used namespaces:
                    </p>
                    <div class="row">
                        <div class="col-12 col-sm-6 col-md-3">0&nbsp;-&nbsp;<tt>user.</tt></div>
                        <div class="col-12 col-sm-6 col-md-3">1&nbsp;-&nbsp;<tt>trusted.</tt></div>
                        <div class="col-12 col-sm-6 col-md-3">2&nbsp;-&nbsp;<tt>security.</tt></div>
                    </div>
                    <br/>
                    <p>
                        This means that on the one hand squashfs can store SELinux labels or capabilities since those are stored in the <tt>security.*</tt> namespaces, but cannot store ACLs which are stored in <tt>system.posix_acl_access</tt> because it has no way to encode the <tt>system.</tt> prefix yet.
                    </p>
                    <p>
                        The key value pairs of all inodes are stored consecutively in <a href="#metadata-blocks">metadata blocks</a>. The values can be either be stored inline, i.e. an Xattr Key Entry is directly followed by an Xattr Value Entry, or out of line to deduplicate identical values.
                    </p>
                    <p>
                        If a value is stored out of line, the value entry structure holds a 64 bit reference instead of a string that specifies the location of the value string, similar to an <a href="#inode-references">inode reference</a>, but relative to the the first metadata block containing the key value pairs.
                    </p>
                    <p>
                        Typically, the first occurrence of a value is stored in line and every consecutive use of the same value uses an out of line value to refer back to the first one.
                    </p>
                    <h4>Xattr Key Entry</h4>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>type</td>
                                <td>u16</td>
                                <td>The ID of the key prefix. If the value that follows is stored out of line, the flag 0x0100 is ORed to the type ID</td>
                            </tr>
                            <tr>
                                <td>name_size</td>
                                <td>u16</td>
                                <td>The size of the key name <b>including</b> the omitted prefix but exlcuding the trailing null byte</td>
                            </tr>
                            <tr>
                                <td>name</td>
                                <td>u8[name_size - strlen(prefix)]</td>
                                <td>The remainder of the key without the prefix and without trailing null byte</td>
                            </tr>
                        </tbody>
                    </table>
                    <h4>Xattr Value Entry</h4>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>value_size</td>
                                <td>u32</td>
                                <td>The size of the value string. If the value is stored out of line, this is always 8, i.e. the size of an unsigned 64 bit integer</td>
                            </tr>
                            <tr>
                                <td>value</td>
                                <td>u8[value_size]</td>
                                <td>The raw value assigned to the key without trailing null byte, or if the value is stored out of line, a reference to the location of the value string</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>
                        To actually address a block of key value pairs associated with an inode, a lookup table is used that specifies the start and size of a block of key value pairs.
                    </p>
                    <p>
                        All an inode needs to store is a 32 bit index into this table. If two inodes have the identical xattrs (e.g. they have the same SELinux labels and no other attributes), the key/value block is only written once, there is only one lookup table entry and both inodes have the same index.
                    </p>
                    <h4>Xattr Lookup Table</h4>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>xattr_ref</td>
                                <td>u64</td>
                                <td>A reference to the start of the key value block. Similar to <a href="#inode-references">inode references</a>, the bits 16 to 48 hold the metadata block index and the lower 16 bit hold an offset into the uncompressed block</td>
                            </tr>
                            <tr>
                                <td>count</td>
                                <td>u32</td>
                                <td>The number of key value pairs</td>
                            </tr>
                            <tr>
                                <td>size</td>
                                <td>u32</td>
                                <td>The exact, uncompressed size in bytes of the entire block of key value pairs, counting only what has been written to disk and including the key/value entry structures</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>
                        In order to locate both tables on disk, an approach similar to ID and fragment tables is used. The following data structure is stored directly on in the archive (i.e. uncompressed and without additional headers).
                    </p>
                    <p>
                        The <code class="field-name">xattr_id_table_start</code> in the <a href="#superblock">superblock</a> stores the absolute position of this table.
                    </p>
                    <h4>Xattr ID Table</h4>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>xattr_table_start</td>
                                <td>u64</td>
                                <td>The absolute position of the first metadata block holding the key/value pairs.</td>
                            </tr>
                            <tr>
                                <td>xattr_ids</td>
                                <td>u32</td>
                                <td>The number of entries in the Xattr Lookup Table</td>
                            </tr>
                            <tr>
                                <td>_unused</td>
                                <td>u32</td>
                                <td>This field is unused</td>
                            </tr>
                            <tr>
                                <td>table</td>
                                <td>u64[]</td>
                                <td>The absolute locations of each metadata block of the Xattr Lookup Table. Each entry is 16 bytes in size, so a block can hold at most 512 entries. Thus this array has <code>ceil(<span class="field-name">xattr_ids</span> / 512.0)</code> entries.</td>
                            </tr>
                        </tbody>
                    </table>
                </section>
            </div>
        </div>
        <footer class="py-4 pt-md-5 border-top">
            <div class="row">
                <div class="col-12 text-center">
                    <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
                </div>
            </div>
        </footer>
    </div>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>

</html>
